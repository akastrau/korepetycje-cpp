{
    "docs": [
        {
            "location": "/",
            "text": "Witaj w kursie podstaw programowania w j\u0119zyku C++!\n\u00b6\n\n\nKody \u017ar\u00f3d\u0142owe znajduj\u0105 si\u0119 w \nrepozytorium Bitbucket\n.\n\n\n\n\nWskaz\u00f3wka\n\n\nOdno\u015bnik do repozytorium znajduje si\u0119 tak\u017ce w prawym g\u00f3rnym rogu menu.\n\n\n\n\nS\u0142owo na niedziel\u0119... czyli kr\u00f3tki wst\u0119p\n\u00b6\n\n\nO czym b\u0119dzie ten kurs\n\u00b6\n\n\nMateria\u0142y umieszczone na tej stronie s\u0105 elementami pomocniczymi do nauki j\u0119zyka C++. Wszystkie inne aspekty om\u00f3wione b\u0119d\u0105 na zaj\u0119ciach. Nie b\u0119d\u0119 za bardzo wnika\u0142 w teorie (jednak niekt\u00f3re elementy kr\u00f3tko opisze).\n\n\nKurs b\u0119dzie na bie\u017c\u0105co zmieniany. Cz\u0119\u015b\u0107 \u0107wicze\u0144 b\u0119d\u0105 umieszczone w repozytorium. Materia\u0142y o kt\u00f3rych wspomnia\u0142em maj\u0105 posta\u0107 mini \u015bci\u0105gawki (warto zapozna\u0107 si\u0119 z nimi przed zaj\u0119ciami).\n\n\nO czym nie b\u0119dzie ten kurs\n\u00b6\n\n\nNie b\u0119dziemy zajmowa\u0107 si\u0119 tematyk\u0105 algorytm\u00f3w (jest wiele ciekawych pozycji ju\u017c na ten temat). Nie b\u0119dziemy tak\u017ce skupia\u0107 si\u0119 tak bardzo na metodykach wytwarzania oprogramowania (bo tym zajmuj\u0119 si\u0119 in\u017cyneria oprogramowania).\n\n\nStruktura kursu\n\u00b6\n\n\nKurs podzieli\u0142em na dwie zasadnicze cz\u0119\u015bci. Pierwsza bardzo wa\u017cna omawia programowanie proceduralne w j\u0119zyku C. Druga za\u015b b\u0119dzie opisywa\u0107 programowanie zorientowane obiektowo, czyli pewne podej\u015bcie wykorzystywane w wielu systemach informatycznych.\n\n\nW pierwszej cz\u0119\u015bci nie zabraknie podstawowych aspekt\u00f3w programowania (podstawowe typy i struktury danych). Poka\u017ce w niej tak\u017ce w jaki spos\u00f3b sterowa\u0107 dzia\u0142aniem programu (z ang. control flow). Do tego wszystkiego nauczymy si\u0119 korzysta\u0107 z dobrodziejstw debuggera.\n\n\nNast\u0119pnie wejdziemy w \u015bwiat programowania zorietowanego obiektowo. Poznamy r\u00f3\u017cnice mi\u0119dzy programowaniem proceduralnym i obiektowym. Nauczymy si\u0119 modelowa\u0107 programy w podej\u015bciu obiektowym.\n\n\nDlaczego j\u0119zyk C?\n\u00b6\n\n\nZaczynamy od tego j\u0119zyka z kilku powod\u00f3w:\n\n\n\n\nJest prostszy w swojej strukturze (brak z\u0142o\u017conych obiekt\u00f3w), \n\n\nBiblioteka standardowa jest ma\u0142a (je\u015bli chodzi o ilo\u015b\u0107 funkcji w por\u00f3wnaniu do j\u0119zyka C++),\n\n\nNauczymy si\u0119 operowa\u0107 na wska\u017anikach (pozwoli nam to zrozumie\u0107 pewne mechanizmy istniej\u0105ce w jezykach bazuj\u0105cych na j\u0119zyku C),\n\n\nDaje nam dost\u0119p bezpo\u015brednio do pami\u0119ci RAM (ni\u017cej jest tylko j\u0119zyk Asembler).\n\n\n\n\n\n\n\u0179r\u00f3d\u0142o: https://comm2302metafiction.wordpress.com/2012/10/03/the-equal-dilemma/\n\n\nTo wszystko pozwoli nam na p\u0142ynne przej\u015bcie do C++.\n\n\n\u0179r\u00f3d\u0142a wiedzy (polecane przeze mnie)\n\u00b6\n\n\nCzytanie dokumentacji to bardzo wa\u017cna umiej\u0119tno\u015b\u0107! Dlatego polecam u\u017cywa\u0107 dokumentacji z przyk\u0142adami.\nNa co dzie\u0144 korzystam z dokumentacji z portalu \ncplusplus.com\n. Mo\u017cna tam znale\u017a\u0107 tutorale dotycz\u0105ce j\u0119zyka C i C++. Drug\u0105 stron\u0105, kt\u00f3ry kazdy programista powinien zna\u0107 to \nStack Overflow\n.\n\n\n\n\n\u0179r\u00f3d\u0142o: imgur.com\n\n\nZ jakiego IDE polecam korzysta\u0107\n\u00b6\n\n\nIDE to \u015brodowisko programistyczne kt\u00f3rego w sk\u0142ad wchodz\u0105:\n\n\n\n\nkompilator\n\n\nlinker\n\n\ndebugger\n\n\ni najcz\u0119\u015bciej inne narz\u0119dzia pomagaj\u0105ce w pisaniu kodu.\n\n\n\n\nNa zaj\u0119ciach bedziemy korzysta\u0107 z Visual Studio 2017 (wersja community - do pobrania za darmo).\n\n\n\n\u0179r\u00f3d\u0142o: http://i.memecaptain.com/gend_images/loHMIw.jpg\n\n\nSystem kontroli wersji\n\u00b6\n\n\nNa zaj\u0119ciach b\u0119dziemy korzysta\u0107 z system\u00f3w kontroli wersji opartych o technologie Git. Wszystkie instrukcje co do konfiguracji \u015brodowiska b\u0119d\u0105/zosta\u0142y om\u00f3wione na zaj\u0119ciach.\n\n\nAlgorytmy + struktury danych = programy\n\u00b6\n\n\n\n\nKsi\u0105\u017cka napisana przez Niklausa Wirtha \u015bwietnie ukazuj\u0105ca istote algorytm\u00f3w i struktur danych.",
            "title": "Strona g\u0142\u00f3wna"
        },
        {
            "location": "/#witaj-w-kursie-podstaw-programowania-w-jezyku-c",
            "text": "Kody \u017ar\u00f3d\u0142owe znajduj\u0105 si\u0119 w  repozytorium Bitbucket .   Wskaz\u00f3wka  Odno\u015bnik do repozytorium znajduje si\u0119 tak\u017ce w prawym g\u00f3rnym rogu menu.",
            "title": "Witaj w kursie podstaw programowania w j\u0119zyku C++!"
        },
        {
            "location": "/#sowo-na-niedziele-czyli-krotki-wstep",
            "text": "",
            "title": "S\u0142owo na niedziel\u0119... czyli kr\u00f3tki wst\u0119p"
        },
        {
            "location": "/#o-czym-bedzie-ten-kurs",
            "text": "Materia\u0142y umieszczone na tej stronie s\u0105 elementami pomocniczymi do nauki j\u0119zyka C++. Wszystkie inne aspekty om\u00f3wione b\u0119d\u0105 na zaj\u0119ciach. Nie b\u0119d\u0119 za bardzo wnika\u0142 w teorie (jednak niekt\u00f3re elementy kr\u00f3tko opisze).  Kurs b\u0119dzie na bie\u017c\u0105co zmieniany. Cz\u0119\u015b\u0107 \u0107wicze\u0144 b\u0119d\u0105 umieszczone w repozytorium. Materia\u0142y o kt\u00f3rych wspomnia\u0142em maj\u0105 posta\u0107 mini \u015bci\u0105gawki (warto zapozna\u0107 si\u0119 z nimi przed zaj\u0119ciami).",
            "title": "O czym b\u0119dzie ten kurs"
        },
        {
            "location": "/#o-czym-nie-bedzie-ten-kurs",
            "text": "Nie b\u0119dziemy zajmowa\u0107 si\u0119 tematyk\u0105 algorytm\u00f3w (jest wiele ciekawych pozycji ju\u017c na ten temat). Nie b\u0119dziemy tak\u017ce skupia\u0107 si\u0119 tak bardzo na metodykach wytwarzania oprogramowania (bo tym zajmuj\u0119 si\u0119 in\u017cyneria oprogramowania).",
            "title": "O czym nie b\u0119dzie ten kurs"
        },
        {
            "location": "/#struktura-kursu",
            "text": "Kurs podzieli\u0142em na dwie zasadnicze cz\u0119\u015bci. Pierwsza bardzo wa\u017cna omawia programowanie proceduralne w j\u0119zyku C. Druga za\u015b b\u0119dzie opisywa\u0107 programowanie zorientowane obiektowo, czyli pewne podej\u015bcie wykorzystywane w wielu systemach informatycznych.  W pierwszej cz\u0119\u015bci nie zabraknie podstawowych aspekt\u00f3w programowania (podstawowe typy i struktury danych). Poka\u017ce w niej tak\u017ce w jaki spos\u00f3b sterowa\u0107 dzia\u0142aniem programu (z ang. control flow). Do tego wszystkiego nauczymy si\u0119 korzysta\u0107 z dobrodziejstw debuggera.  Nast\u0119pnie wejdziemy w \u015bwiat programowania zorietowanego obiektowo. Poznamy r\u00f3\u017cnice mi\u0119dzy programowaniem proceduralnym i obiektowym. Nauczymy si\u0119 modelowa\u0107 programy w podej\u015bciu obiektowym.",
            "title": "Struktura kursu"
        },
        {
            "location": "/#dlaczego-jezyk-c",
            "text": "Zaczynamy od tego j\u0119zyka z kilku powod\u00f3w:   Jest prostszy w swojej strukturze (brak z\u0142o\u017conych obiekt\u00f3w),   Biblioteka standardowa jest ma\u0142a (je\u015bli chodzi o ilo\u015b\u0107 funkcji w por\u00f3wnaniu do j\u0119zyka C++),  Nauczymy si\u0119 operowa\u0107 na wska\u017anikach (pozwoli nam to zrozumie\u0107 pewne mechanizmy istniej\u0105ce w jezykach bazuj\u0105cych na j\u0119zyku C),  Daje nam dost\u0119p bezpo\u015brednio do pami\u0119ci RAM (ni\u017cej jest tylko j\u0119zyk Asembler).    \u0179r\u00f3d\u0142o: https://comm2302metafiction.wordpress.com/2012/10/03/the-equal-dilemma/  To wszystko pozwoli nam na p\u0142ynne przej\u015bcie do C++.",
            "title": "Dlaczego j\u0119zyk C?"
        },
        {
            "location": "/#zroda-wiedzy-polecane-przeze-mnie",
            "text": "Czytanie dokumentacji to bardzo wa\u017cna umiej\u0119tno\u015b\u0107! Dlatego polecam u\u017cywa\u0107 dokumentacji z przyk\u0142adami.\nNa co dzie\u0144 korzystam z dokumentacji z portalu  cplusplus.com . Mo\u017cna tam znale\u017a\u0107 tutorale dotycz\u0105ce j\u0119zyka C i C++. Drug\u0105 stron\u0105, kt\u00f3ry kazdy programista powinien zna\u0107 to  Stack Overflow .   \u0179r\u00f3d\u0142o: imgur.com",
            "title": "\u0179r\u00f3d\u0142a wiedzy (polecane przeze mnie)"
        },
        {
            "location": "/#z-jakiego-ide-polecam-korzystac",
            "text": "IDE to \u015brodowisko programistyczne kt\u00f3rego w sk\u0142ad wchodz\u0105:   kompilator  linker  debugger  i najcz\u0119\u015bciej inne narz\u0119dzia pomagaj\u0105ce w pisaniu kodu.   Na zaj\u0119ciach bedziemy korzysta\u0107 z Visual Studio 2017 (wersja community - do pobrania za darmo).  \u0179r\u00f3d\u0142o: http://i.memecaptain.com/gend_images/loHMIw.jpg",
            "title": "Z jakiego IDE polecam korzysta\u0107"
        },
        {
            "location": "/#system-kontroli-wersji",
            "text": "Na zaj\u0119ciach b\u0119dziemy korzysta\u0107 z system\u00f3w kontroli wersji opartych o technologie Git. Wszystkie instrukcje co do konfiguracji \u015brodowiska b\u0119d\u0105/zosta\u0142y om\u00f3wione na zaj\u0119ciach.",
            "title": "System kontroli wersji"
        },
        {
            "location": "/#algorytmy-struktury-danych-programy",
            "text": "Ksi\u0105\u017cka napisana przez Niklausa Wirtha \u015bwietnie ukazuj\u0105ca istote algorytm\u00f3w i struktur danych.",
            "title": "Algorytmy + struktury danych = programy"
        },
        {
            "location": "/c/",
            "text": "Cz\u0119\u015b\u0107 pierwsza kursu - podstawy programowania w j\u0119zyku C\n\u00b6\n\n\nW tej cz\u0119\u015bci skupimy si\u0119 na podstawowych elementach tego j\u0119zyka. Poznamy w jaki spos\u00f3b definiuje si\u0119 funkcje. Nie zabraknie te\u017c zabawy ze wska\u017anikami oraz ze strukturami danych.\n\n\n\n\n\u0179r\u00f3d\u0142o: http://www.quickmeme.com/meme/3ovgn9\n\n\nOstatnia aktualizacja:\n Thu Sep 21 14:18:09 CEST 2017",
            "title": "Cz\u0119\u015b\u0107 pierwsza kursu - podstawy programowania w j\u0119zyku C"
        },
        {
            "location": "/c/#czesc-pierwsza-kursu-podstawy-programowania-w-jezyku-c",
            "text": "W tej cz\u0119\u015bci skupimy si\u0119 na podstawowych elementach tego j\u0119zyka. Poznamy w jaki spos\u00f3b definiuje si\u0119 funkcje. Nie zabraknie te\u017c zabawy ze wska\u017anikami oraz ze strukturami danych.   \u0179r\u00f3d\u0142o: http://www.quickmeme.com/meme/3ovgn9  Ostatnia aktualizacja:  Thu Sep 21 14:18:09 CEST 2017",
            "title": "Cz\u0119\u015b\u0107 pierwsza kursu - podstawy programowania w j\u0119zyku C"
        },
        {
            "location": "/lesson01-p1/",
            "text": "Pierwsze koty za p\u0142oty... czyli nasza pierwsza aplikacja napisana w j\u0119zyku C\n\u00b6\n\n\nJak zacz\u0105\u0107\n\u00b6\n\n\nW Visual Studio tworzymy nowy projekt C++. Wybieramy \nEmpty Project\n. Po utworzeniu nowego projektu musimy utworzy\u0107 nowy plik (niech to b\u0119dzie plik \nSource.c\n). Rozszerzenie \n.c\n m\u00f3wi nam o tym, \u017ce nasz kod \u017ar\u00f3d\u0142owy b\u0119dzie pisany w j\u0119zyku C.\n\n\n\n\n\u0179r\u00f3d\u0142o: http://devhumor.com/media/i-can-write-quot-hello-world-quot-in-c\n\n\nNo to jazda, jazda, jazda, tr\u00f3jk\u0105t, gwiazda!\n\u00b6\n\n\nNapiszmy:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n#include\n \n<stdio.h>\n\n\n#include\n \n<stdlib.h>\n\n\n\nint\n \nmain\n()\n\n\n{\n\n    \nint\n \nvariable\n \n=\n \n4\n;\n\n    \nprintf\n(\n\"Hello! Your number is %i!\n\\n\n\"\n,\n \nvariable\n);\n\n\n    \nsystem\n(\n\"pause\"\n);\n\n    \nreturn\n \n0\n;\n\n\n}\n\n\n\n\n\n\n\nCo tutaj si\u0119 sta\u0142o? W pierwszej linijce napisali\u015bmy \n#include <stdio.h>\n. Oznacza to, \u017ce kompilator do\u0142\u0105czy za nas biblioteke \nstdio.h\n. W drugiej za\u015b bibliotek\u0119 \nstdlib.h\n.\n\n\nDlaczego te biblioteki do\u0142\u0105czyli\u015bmy? Pierwsza z nich to \nSTanDard Input Output library\n. Znajdziemy w niej podstawowe funkcje wej\u015bcia/wyj\u015bcia (takie jak wypisywanie tekstu na ekran). Z kolei \nstdlib.h\n to \nSTanDard LIBrary\n. Znajdziemy w niej postawowe sta\u0142e i makra takie jak \nEXIT_SUCCESS\n.\n\n\n\n\nCiekawostka\n\n\nMakro \nEXIT_SUCCESS\n to pewna sta\u0142a.\nW bibliotece standardowej sta\u0142a \nEXIT_SUCCESS\n przyjmuje warto\u015b\u0107 \n0\n\nIstnieje tak\u017ce makro \nEXIT_FAILURE\n, kt\u00f3re definiuje warto\u015b\u0107 \n1\n.\n\n\n\n\nFunkcja main - punkt startowy naszej aplikacji\n\u00b6\n\n\nAby nasz program m\u00f3g\u0142 si\u0119 uruchomi\u0107, kompilator musi wiedzie\u0107 w jakim miejscu zaczyna wykonywa\u0107 si\u0119 nasza aplikacja. Takim miejscem jest funkcja \nmain\n. O funkcjach opowiemy sobie w innej lekcji. Na tym etapie zwr\u00f3\u0107 uwage na definicje naszej funkcji startowej:\n\n\n1\n2\n3\n4\n5\nint\n \nmain\n()\n\n\n{\n\n    \n// To jest nasza funkcja glowna\n\n    \nreturn\n \njakas_liczba\n;\n\n\n}\n\n\n\n\n\n\n\nCo oznacza s\u0142\u00f3wko kluczowe \nint\n? Oznacza to tyle, \u017ce funkcja po zako\u0144czeniu swojego dzia\u0142ania zwraca typ zmiennej typu \nint\n. O typach zmiennych opowiemy sobie za moment.\n\n\nNo dobra! Mam funkcje main i co dalej?\n\u00b6\n\n\nPrzyjrzyjmy si\u0119 jeszcze raz na nasz kod \u017ar\u00f3d\u0142owy z pocz\u0105tku lekcji. \n\n\nW linii numer 6 zadeklarowali\u015bmy zmienn\u0105 typu \nint\n o nazwie \nvariable\n. Dzi\u0119ki takiej deklaracji mo\u017cemy u\u017cy\u0107 naszej zmiennej w obr\u0119bie naszej funkcji (jest to zmienna lokalna). \n\n\nW kolejnej linijce u\u017cyli\u015bmy funkcji wbudowanej \nprintf()\n (printf to skr\u00f3t od \nprint formatted\n). Wy\u015bwietla ona sformatowany tekst. Sp\u00f3jrzmy na pierwszy argument, kt\u00f3ry wchodzi do naszej funkcji:\n\n\"Hello! Your number is %i!\\n\"\n. Jest to tekst, kt\u00f3ry zostanie wy\u015bwietlony na ekranie. \n%i\n oznacza, \u017ce kompilator podstawi tu zmienn\u0105 typu \nint\n. \n\\n\n na ko\u0144cu naszego tekstu oznacza znak nowej linii (z ang. \nnewline\n). Jako drugi argument w funkcji \nprintf()\n podali\u015bmy zmienn\u0105 \nvariable\n. Dzi\u0119ki temu funkcja \nprintf()\n podstawi warto\u015b\u0107 zmiennej pod \n%i\n.\n\n\nW linii numer 8 u\u017cyli\u015bmy funkcji \nsystem()\n. Funkcja ta wywo\u0142uje polecenie systemowe (w naszym przypadku jest to polecenie \npause\n, kt\u00f3re zatrzymuje dzia\u0142anie naszego programu i oczekuje na wci\u015bni\u0119cie dowolnego klawisza). Niestety polecenie \npause\n dzia\u0142a tylko w systemach Windows. W przypadku innych system\u00f3w musimy u\u017cy\u0107 innego rozwi\u0105zania, \u017ceby zatrzyma\u0107 dzia\u0142anie programu.\n\n\nW ostatniej linii napisali\u015bmy \nreturn 0\n co oznacza, \u017ce program zwr\u00f3ci liczb\u0119 0 po zako\u0144czeniu dzia\u0142ania.\n\n\nKilka s\u0142\u00f3w o typach w C\n\u00b6\n\n\nMamy klika rodzaj\u00f3w zmiennych. S\u0105 to zmienne:\n\n\n\n\ntypu \nint\n, czyli liczby ca\u0142kowite 32-bitowe,\n\n\ntypu \nfloat\n, czyli liczby zmiennoprzecinkowe pojedynczej precyzji,\n\n\ntypu \ndouble\n, czyli liczby zmiennoprzecinkowe podw\u00f3jnej precyzji,\n\n\ntypu \nchar\n, czyli znak/litera lub \nchar\n* w przypadku \u0142a\u0144cuchu znak\u00f3w, czyli tekstu.\n\n\n\n\nOczywi\u015bcie mamy jeszcze wariant ze s\u0142owem \nlong\n, ale na tym etapie nie b\u0119d\u0119 o nim wspomina\u0107.\n\n\n\n\nWi\u0119cej o typach podstawowych\n\n\nWi\u0119cej informacji na temat typ\u00f3w podstawowych znajdziesz na przyk\u0142ad \ntu\n.\n\n\n\n\nFunkcja printf()\n\u00b6\n\n\nPrzy wywo\u0142aniu funkcji \nprintf()\n skorzystali\u015bmy z \n%i\n. Jest to tzw. \nformat specifier\n. Na podstawie dokumentacji z \ncplusplus.com\n wymienimy kilka dost\u0119pnych format\u00f3w wy\u015bwietlanych danych. Mi\u0119dzy innymi s\u0105 to:\n\n\n\n\n%i\n lub \n%d\n dla liczb typu ca\u0142kowitego,\n\n\n%f\n dla liczby zmiennoprzecinkowych,\n\n\n%c\n dla pojedynczego znaku,\n\n\n%s\n dla \u0142a\u0144cucha znaku.\n\n\n\n\nW funkcji \nprintf()\n mo\u017cna u\u017cy\u0107 specjalnych znak\u00f3w za pomoc\u0105 \n\\\n (przyk\u0142ad \n\\n\n). Zach\u0119cam do poczytania dokumentacji tej funkcji.\n\n\nNa zako\u0144czenie - return ITS_THE_END\n\u00b6\n\n\nS\u0142\u00f3wko kluczowe \nreturn\n w funkcji \nmain()\n wykorzystujemy po to, aby zasygnalizowa\u0107 stan wykonania naszego programu. Zwykle zwraca si\u0119:\n\n\n\n\n0\n, gdy program zako\u0144czy\u0142 sie poprawnie,\n\n\n1\n lub liczb\u0119 ujemn\u0105 gdy program zako\u0144czy\u0142 si\u0119 pora\u017ck\u0105.\n\n\n\n\nPraktyka czyni mistrza... czyli zadania do zrobienia\n\u00b6\n\n\nKod do zadania wygl\u0105da nast\u0119puj\u0105co:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n#include\n \n<stdio.h>\n\n\n#include\n \n<stdlib.h>\n\n\n\nint\n \nmain\n(\nvoid\n)\n\n\n{\n\n    \nconst\n \ndouble\n \npi\n \n=\n \n3.14159265\n;\n\n    \nchar\n \ntext\n[]\n \n=\n \n\"Some text here\"\n;\n\n    \nint\n \nnumber\n \n=\n \n1246754\n;\n\n\n    \n// Uzupelnij kod\n\n\n    \nsystem\n(\n\"pause\"\n);\n\n    \nreturn\n \nEXIT_SUCCESS\n;\n\n\n}\n\n\n\n\n\n\n\nZadania:\n\n\n\n\nWy\u015bwietl liczb\u0119 pi z dok\u0142adno\u015bci\u0105 do trzeciego miejsca po przecinku,\n\n\nWy\u015bwietl znak 1, 3 i 8 z \u0142a\u0144cucha \ntext\n,\n\n\nWy\u015bwietl liczb\u0119 \nnumber\n,\n\n\nWy\u015bwietl \u0142a\u0144cuch znak\u00f3w \ntext\n.",
            "title": "Lekcja 01: Pierwszy program"
        },
        {
            "location": "/lesson01-p1/#pierwsze-koty-za-poty-czyli-nasza-pierwsza-aplikacja-napisana-w-jezyku-c",
            "text": "",
            "title": "Pierwsze koty za p\u0142oty... czyli nasza pierwsza aplikacja napisana w j\u0119zyku C"
        },
        {
            "location": "/lesson01-p1/#jak-zaczac",
            "text": "W Visual Studio tworzymy nowy projekt C++. Wybieramy  Empty Project . Po utworzeniu nowego projektu musimy utworzy\u0107 nowy plik (niech to b\u0119dzie plik  Source.c ). Rozszerzenie  .c  m\u00f3wi nam o tym, \u017ce nasz kod \u017ar\u00f3d\u0142owy b\u0119dzie pisany w j\u0119zyku C.   \u0179r\u00f3d\u0142o: http://devhumor.com/media/i-can-write-quot-hello-world-quot-in-c",
            "title": "Jak zacz\u0105\u0107"
        },
        {
            "location": "/lesson01-p1/#no-to-jazda-jazda-jazda-trojkat-gwiazda",
            "text": "Napiszmy:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11 #include   <stdio.h>  #include   <stdlib.h>  int   main ()  { \n     int   variable   =   4 ; \n     printf ( \"Hello! Your number is %i! \\n \" ,   variable ); \n\n     system ( \"pause\" ); \n     return   0 ;  }    Co tutaj si\u0119 sta\u0142o? W pierwszej linijce napisali\u015bmy  #include <stdio.h> . Oznacza to, \u017ce kompilator do\u0142\u0105czy za nas biblioteke  stdio.h . W drugiej za\u015b bibliotek\u0119  stdlib.h .  Dlaczego te biblioteki do\u0142\u0105czyli\u015bmy? Pierwsza z nich to  STanDard Input Output library . Znajdziemy w niej podstawowe funkcje wej\u015bcia/wyj\u015bcia (takie jak wypisywanie tekstu na ekran). Z kolei  stdlib.h  to  STanDard LIBrary . Znajdziemy w niej postawowe sta\u0142e i makra takie jak  EXIT_SUCCESS .   Ciekawostka  Makro  EXIT_SUCCESS  to pewna sta\u0142a.\nW bibliotece standardowej sta\u0142a  EXIT_SUCCESS  przyjmuje warto\u015b\u0107  0 \nIstnieje tak\u017ce makro  EXIT_FAILURE , kt\u00f3re definiuje warto\u015b\u0107  1 .",
            "title": "No to jazda, jazda, jazda, tr\u00f3jk\u0105t, gwiazda!"
        },
        {
            "location": "/lesson01-p1/#funkcja-main-punkt-startowy-naszej-aplikacji",
            "text": "Aby nasz program m\u00f3g\u0142 si\u0119 uruchomi\u0107, kompilator musi wiedzie\u0107 w jakim miejscu zaczyna wykonywa\u0107 si\u0119 nasza aplikacja. Takim miejscem jest funkcja  main . O funkcjach opowiemy sobie w innej lekcji. Na tym etapie zwr\u00f3\u0107 uwage na definicje naszej funkcji startowej:  1\n2\n3\n4\n5 int   main ()  { \n     // To jest nasza funkcja glowna \n     return   jakas_liczba ;  }    Co oznacza s\u0142\u00f3wko kluczowe  int ? Oznacza to tyle, \u017ce funkcja po zako\u0144czeniu swojego dzia\u0142ania zwraca typ zmiennej typu  int . O typach zmiennych opowiemy sobie za moment.",
            "title": "Funkcja main - punkt startowy naszej aplikacji"
        },
        {
            "location": "/lesson01-p1/#no-dobra-mam-funkcje-main-i-co-dalej",
            "text": "Przyjrzyjmy si\u0119 jeszcze raz na nasz kod \u017ar\u00f3d\u0142owy z pocz\u0105tku lekcji.   W linii numer 6 zadeklarowali\u015bmy zmienn\u0105 typu  int  o nazwie  variable . Dzi\u0119ki takiej deklaracji mo\u017cemy u\u017cy\u0107 naszej zmiennej w obr\u0119bie naszej funkcji (jest to zmienna lokalna).   W kolejnej linijce u\u017cyli\u015bmy funkcji wbudowanej  printf()  (printf to skr\u00f3t od  print formatted ). Wy\u015bwietla ona sformatowany tekst. Sp\u00f3jrzmy na pierwszy argument, kt\u00f3ry wchodzi do naszej funkcji: \"Hello! Your number is %i!\\n\" . Jest to tekst, kt\u00f3ry zostanie wy\u015bwietlony na ekranie.  %i  oznacza, \u017ce kompilator podstawi tu zmienn\u0105 typu  int .  \\n  na ko\u0144cu naszego tekstu oznacza znak nowej linii (z ang.  newline ). Jako drugi argument w funkcji  printf()  podali\u015bmy zmienn\u0105  variable . Dzi\u0119ki temu funkcja  printf()  podstawi warto\u015b\u0107 zmiennej pod  %i .  W linii numer 8 u\u017cyli\u015bmy funkcji  system() . Funkcja ta wywo\u0142uje polecenie systemowe (w naszym przypadku jest to polecenie  pause , kt\u00f3re zatrzymuje dzia\u0142anie naszego programu i oczekuje na wci\u015bni\u0119cie dowolnego klawisza). Niestety polecenie  pause  dzia\u0142a tylko w systemach Windows. W przypadku innych system\u00f3w musimy u\u017cy\u0107 innego rozwi\u0105zania, \u017ceby zatrzyma\u0107 dzia\u0142anie programu.  W ostatniej linii napisali\u015bmy  return 0  co oznacza, \u017ce program zwr\u00f3ci liczb\u0119 0 po zako\u0144czeniu dzia\u0142ania.",
            "title": "No dobra! Mam funkcje main i co dalej?"
        },
        {
            "location": "/lesson01-p1/#kilka-sow-o-typach-w-c",
            "text": "Mamy klika rodzaj\u00f3w zmiennych. S\u0105 to zmienne:   typu  int , czyli liczby ca\u0142kowite 32-bitowe,  typu  float , czyli liczby zmiennoprzecinkowe pojedynczej precyzji,  typu  double , czyli liczby zmiennoprzecinkowe podw\u00f3jnej precyzji,  typu  char , czyli znak/litera lub  char * w przypadku \u0142a\u0144cuchu znak\u00f3w, czyli tekstu.   Oczywi\u015bcie mamy jeszcze wariant ze s\u0142owem  long , ale na tym etapie nie b\u0119d\u0119 o nim wspomina\u0107.   Wi\u0119cej o typach podstawowych  Wi\u0119cej informacji na temat typ\u00f3w podstawowych znajdziesz na przyk\u0142ad  tu .",
            "title": "Kilka s\u0142\u00f3w o typach w C"
        },
        {
            "location": "/lesson01-p1/#funkcja-printf",
            "text": "Przy wywo\u0142aniu funkcji  printf()  skorzystali\u015bmy z  %i . Jest to tzw.  format specifier . Na podstawie dokumentacji z  cplusplus.com  wymienimy kilka dost\u0119pnych format\u00f3w wy\u015bwietlanych danych. Mi\u0119dzy innymi s\u0105 to:   %i  lub  %d  dla liczb typu ca\u0142kowitego,  %f  dla liczby zmiennoprzecinkowych,  %c  dla pojedynczego znaku,  %s  dla \u0142a\u0144cucha znaku.   W funkcji  printf()  mo\u017cna u\u017cy\u0107 specjalnych znak\u00f3w za pomoc\u0105  \\  (przyk\u0142ad  \\n ). Zach\u0119cam do poczytania dokumentacji tej funkcji.",
            "title": "Funkcja printf()"
        },
        {
            "location": "/lesson01-p1/#na-zakonczenie-return-its_the_end",
            "text": "S\u0142\u00f3wko kluczowe  return  w funkcji  main()  wykorzystujemy po to, aby zasygnalizowa\u0107 stan wykonania naszego programu. Zwykle zwraca si\u0119:   0 , gdy program zako\u0144czy\u0142 sie poprawnie,  1  lub liczb\u0119 ujemn\u0105 gdy program zako\u0144czy\u0142 si\u0119 pora\u017ck\u0105.",
            "title": "Na zako\u0144czenie - return ITS_THE_END"
        },
        {
            "location": "/lesson01-p1/#praktyka-czyni-mistrza-czyli-zadania-do-zrobienia",
            "text": "Kod do zadania wygl\u0105da nast\u0119puj\u0105co:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14 #include   <stdio.h>  #include   <stdlib.h>  int   main ( void )  { \n     const   double   pi   =   3.14159265 ; \n     char   text []   =   \"Some text here\" ; \n     int   number   =   1246754 ; \n\n     // Uzupelnij kod \n\n     system ( \"pause\" ); \n     return   EXIT_SUCCESS ;  }    Zadania:   Wy\u015bwietl liczb\u0119 pi z dok\u0142adno\u015bci\u0105 do trzeciego miejsca po przecinku,  Wy\u015bwietl znak 1, 3 i 8 z \u0142a\u0144cucha  text ,  Wy\u015bwietl liczb\u0119  number ,  Wy\u015bwietl \u0142a\u0144cuch znak\u00f3w  text .",
            "title": "Praktyka czyni mistrza... czyli zadania do zrobienia"
        },
        {
            "location": "/lesson02-p1/",
            "text": "Lekcja 2: kilka s\u0142\u00f3w o p\u0119tlach i operacjach wej\u015bcia i wyj\u015bcia\n\u00b6\n\n\nW poprzedniej lekcji poznali\u015bmy podstawowe typy danych oraz funkcje \nprintf()\n. W tej lekcji zajmiemy si\u0119 kontrol\u0105 wykonania naszego kodu.\n\n\nPrzyk\u0142ad 1\n\u00b6\n\n\nZerknijmy na poni\u017cszy kod:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n#include\n \n<stdio.h>\n\n\n#include\n \n<stdlib.h>\n\n\n\nint\n \nmain\n()\n\n\n{\n\n    \nchar\n \nname\n[\n35\n];\n\n    \nchar\n \nmyName\n[]\n \n=\n \n\"Alice\"\n;\n \n// char myName[] = {'A', 'l', 'i', 'c', 'e'}; lub char* myName = \"Alice\";\n\n    \nint\n \nage\n \n=\n \n0\n;\n\n    \nprintf\n(\n\"Hi, I'm %s! What's your name?: \"\n,\n \nmyName\n);\n\n    \nscanf\n(\n\"%s\"\n,\n \nname\n);\n\n\n    \nprintf\n(\n\"Hi %s! How old are you? \"\n,\n \nname\n);\n\n    \nscanf\n(\n\"%i\"\n,\n \n&\nage\n);\n\n\n    \nif\n \n(\nage\n \n<\n \n18\n)\n\n    \n{\n\n        \nprintf\n(\n\"This content is not available for you! Sorry, dude!\n\\n\n\"\n);\n\n        \nprintf\n(\n\"Returning -1!\n\\n\n\"\n);\n\n        \nsystem\n(\n\"pause\"\n);\n\n        \nreturn\n \n-\n1\n;\n\n    \n}\n\n    \nelse\n \n    \n{\n\n        \nprintf\n(\n\"Ok, You're in!\n\\n\n\"\n);\n\n    \n}\n\n\n    \nsystem\n(\n\"pause\"\n);\n\n    \nreturn\n \n0\n;\n\n\n}\n\n\n\n\n\n\n\nW pierwszych liniach funkcji main zadeklarowali\u015bmy tablice (pierwsza pusta o rozmiarze maksymalnym 35 znak\u00f3w i druga zawieraj\u0105ca napis \"Alice\"). Kazda tablica typu char powinna by\u0107 zako\u0144czona znakiem '\\0' (null-terminated string). Znak null zostanie dodany automatycznie w naszym przypadku.\n\n\nDalej nie dzieje, si\u0119 nic szczeg\u00f3lnego. Zwr\u00f3\u0107my jednak uwage na funkcje \nscanf()\n. Jest to funkcja podobna do funkcji \nprintf()\n. Jej zadaniem jest wczytanie danych z klawiatury, nast\u0119pnie umie\u015bci\u0107 je w odpowiednim miejscu. Miejsce te definiowane jest przez \nwska\u017anik\n. Wska\u017anik zawiera adres w pami\u0119ci RAM danej zmiennej (wskazuje na zmienn\u0105).\n\n\nTablice typu char s\u0105 automatycznie wska\u017anikami. Wska\u017anik domy\u015blnie wskazuje na pierwszy element w tablicy.\n\n\nFunkcja  \nscanf()\n przyjmuje format danych, kt\u00f3ry ma zosta\u0107 wczytany z klawiatury (tak jak w funkcji \nprintf()\n), a nast\u0119pnie podaje si\u0119 zmienne w postaci wska\u017anikowego, czyli adresy.\n\n\nW postaci zmiennych niewska\u017anikowych robimy to za pomoc\u0105 operatora \n&\n (przyk\u0142ad: \n&x\n -> dostaniemy adres zmiennej x w pami\u0119ci).\n\n\nW przypadku zmiennych, kt\u00f3re s\u0105 wska\u017anikami, przekazujemy warto\u015b\u0107 tak jak zwykle.\n\n\nPotem widzimy blok \nif (warunek) {...} else {...}\n. Kod pod warunkiem \nif\n zostanie wykonany, je\u015bli warto\u015b\u0107 logiczna warunku da warto\u015b\u0107 true (inaczej 1). W naszym wypadku jest to wiek mniejszy od 18 lat.\n\n\nKod w bloku else zostanie wykonany w innym przypadku.\n\n\nNiestety funkcja scanf() jest niebezpieczna. Jednym z zamiennik\u00f3w jest funkcja \nscanf_s()\n dost\u0119pna jedynie w systemach Windows. O innych zamiennikach opowiem w innej lekcji. W VS Studio mo\u017cemy wy\u0142\u0105czy\u0107 sprawdzanie bezpiecze\u0144stwa kodu poprzez wy\u0142\u0105czenie \nSDL checks\n w ustawieniach projektu.\n\n\nPrzyk\u0142ad 2\n\u00b6\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n#include\n \n<stdio.h>\n\n\n#include\n \n<stdlib.h>\n\n\n#include\n \n<string.h>\n\n\n\nint\n \nmain\n()\n\n\n{\n\n    \nchar\n \nanswer\n[\n4\n]\n \n=\n \n{\n \n0\n \n};\n\n    \nwhile\n \n(\n1\n)\n \n{\n\n        \nprintf\n(\n\"Do you know Elizabeth Turner? [yes, no, idk]: \"\n);\n\n        \nscanf_s\n(\n\"%s\"\n,\n \nanswer\n,\n \n4\n);\n\n\n        \nif\n \n(\nstrcmp\n(\nanswer\n,\n \n\"yes\"\n)\n \n==\n \n0\n)\n\n        \n{\n\n            \nprintf\n(\n\"Great!\n\\n\n\"\n);\n\n            \nbreak\n;\n\n        \n}\n\n        \nelse\n \nif\n \n(\nstrcmp\n(\nanswer\n,\n \n\"no\"\n)\n \n==\n \n0\n)\n \n{\n\n            \nprintf\n(\n\"Elizabeth is an actress!\n\\n\n\"\n);\n\n            \nbreak\n;\n\n        \n}\n\n        \nelse\n \nif\n \n(\nstrcmp\n(\nanswer\n,\n \n\"idk\"\n)\n \n==\n \n0\n)\n \n{\n\n            \nprintf\n(\n\"Really!? I'm not sure if you are just stupid or you're trolling!\n\\n\n\"\n);\n\n            \nbreak\n;\n\n        \n}\n\n        \nelse\n \n{\n\n            \nprintf\n(\n\"Do you know Elizabeth Turner? [yes, no, idk]: \"\n);\n\n            \nscanf_s\n(\n\"%s\"\n,\n \nanswer\n,\n \n4\n);\n\n        \n}\n\n    \n}\n\n\n    \nsystem\n(\n\"pause\"\n);\n\n    \nreturn\n \n0\n;\n\n\n}\n\n\n\n\n\n\n\nW tym przyk\u0142adzie u\u017cyli\u015bmy biblioteki \n<string.h>\n do por\u00f3wnywania zmiennych \u0142a\u0144cuchowych. Funkcja \nstrcmpy()\n por\u00f3wnuje dwa wska\u017aniki typu char i zwraca r\u00f3\u017cnic\u0119 w znakach. Je\u015bli oba stringi s\u0105 identyczne to funkcja \nstrcmp()\n zwr\u00f3ci \n0\n.\n\n\n\n\nCiekawostka\n\n\nIstnieje funkcja \nstrcmpi()\n, kt\u00f3ra nie zwraca uwag\u0119 na wielko\u015b\u0107 liter przy por\u00f3wnywaniu.\n\n\nInn\u0105 ciekaw\u0105 funkcj\u0105 jest \nstrlen()\n, kt\u00f3ra zwraca aktualn\u0105 d\u0142ugo\u015b\u0107 tablicy znak\u00f3w.\n\n\n\n\n\n\nUwaga!\n\n\nFunkcja \nscanf_s()\n wymaga podania jeszcze jednego argumentu, w przypadku tekstu. Jest to maksymalna ilo\u015b\u0107 znak\u00f3w jakie mog\u0105 byc zapisane w zmiennej typu char*.\n\n\n\n\nPrzyk\u0142ad 3\n\u00b6\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n#include\n \n<stdio.h>\n\n\n#include\n \n<stdlib.h>\n\n\n#include\n \n<stdbool.h>\n\n\n\nint\n \nmain\n()\n\n\n{\n\n    \nbool\n \ndoIt\n \n=\n \nfalse\n;\n\n    \nint\n \ncounter\n \n=\n \n0\n;\n\n\n    \ndo\n\n    \n{\n\n        \nprintf\n(\n\"Do it? \"\n);\n\n        \ndoIt\n \n==\n \ntrue\n \n?\n \nprintf\n(\n\"Yes!\n\\n\n\"\n)\n \n:\n \nprintf\n(\n\"No!\n\\n\n\"\n);\n\n        \ncounter\n++\n;\n\n    \n}\n \nwhile\n \n(\ndoIt\n);\n\n    \nprintf\n(\n\"Counter: %i\n\\n\n\"\n,\n \ncounter\n);\n\n\n    \nwhile\n \n(\ndoIt\n \n==\n \n1\n)\n \n// doIt == true\n\n    \n{\n\n        \nprintf\n(\n\"Incrementing counter in while loop!\n\\n\n\"\n);\n\n        \ncounter\n++\n;\n\n    \n}\n\n    \nprintf\n(\n\"Counter: %i\n\\n\n\"\n,\n \ncounter\n);\n\n    \ndoIt\n \n=\n \n1\n;\n\n    \nprintf\n(\n\"Do it? \"\n);\n\n    \ndoIt\n \n==\n \ntrue\n \n?\n \nprintf\n(\n\"Yes!\n\\n\n\"\n)\n \n:\n \nprintf\n(\n\"No!\n\\n\n\"\n);\n\n    \nwhile\n \n(\ndoIt\n \n==\n \ntrue\n \n&&\n \ncounter\n \n<\n \n3\n)\n\n    \n{\n\n        \nprintf\n(\n\"Incrementing counter in while loop (another loop)!\n\\n\n\"\n);\n\n        \ncounter\n \n+=\n \n1\n;\n \n// counter++; lub counter = counter + 1;\n\n    \n}\n\n\n    \nsystem\n(\n\"pause\"\n);\n\n    \nreturn\n \n0\n;\n\n\n}\n\n\n\n\n\n\n\nW tym przyk\u0142adzie u\u017cyli\u015bmy biblioteki \n<stdbool.h>\n, \u017ceby m\u00f3c zdefiniowac typ zmiennej typu bool (typu logicznego). Typ logiczny mo\u017ce przyjmowa\u0107 dwie warto\u015bci: \ntrue\n albo \nfalse\n (1 albo 0).\n\n\nDo kontrolowania przep\u0142ywu dzia\u0142ania u\u017cyli\u015bmy \ndo {...} while(warunek)\n (wykonaj najperw operacje pod \ndo\n, potem sprawd\u017a, czy warunek jest prawdziwy. Je\u015bli tak, to powt\u00f3rz operacje). W konstrukcji \nwhile(warunek)\n warunek najpierw jest sprawdzany. Je\u015bli jest on prawdziwy, to kod zostanie wykonany.\n\n\nKod \ncounter++\n inkrementuje (zwi\u0119ksza warto\u015b\u0107) zmienn\u0105 \ncounter\n o 1. Z kolei \ndoIt == true : operacja ? druga_operacja\n to tzw. skr\u00f3cony if.\n\n\nKonstrukcja skr\u00f3conego if'a wygl\u0105da tak:\n\n\nwarunek : (jesli prawdziwy wykonaj operacje) ? (wykonaj, je\u015bli fa\u0142sz)\n\n\nJest to r\u00f3wnowa\u017cne z:\n\n\n1\n2\n3\n4\n5\nif\n \n(\nwarunek\n){\n\n    \n// wykonaj operacje, je\u015bli prawdziwy\n\n\n}\n \nelse\n \n{\n\n    \n// wykonaj, je\u015bli fa\u0142sz\n\n\n}\n\n\n\n\n\n\n\n&&\n oznacza i logiczne (koniunkcja), \n||\n - lub logiczne (alternatywa), a \n!\n - zaprzeczenie (negacje).\n\n\n\n\n\u0179r\u00f3d\u0142o: https://pl.pinterest.com/pin/382735668317221447/\n\n\nPrzyk\u0142ad 4\n\u00b6\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n#include\n \n<stdio.h>\n\n\n#include\n \n<stdlib.h>\n\n\n\nint\n \nmain\n()\n\n\n{\n\n    \nint\n \nsum\n \n=\n \n0\n;\n\n    \nint\n \nn\n \n=\n \n10\n;\n\n    \nfor\n \n(\nint\n \ni\n \n=\n \n1\n;\n \ni\n \n<=\n \nn\n;\n \ni\n++\n)\n\n    \n{\n\n        \nsum\n \n+=\n \ni\n;\n\n    \n}\n\n    \nprintf\n(\n\"Sum: %i\n\\n\n\"\n,\n \nsum\n);\n\n    \nsum\n \n=\n \nn\n \n*\n \n(\nn\n \n+\n \n1\n)\n \n/\n \n2\n;\n\n    \nprintf\n(\n\"Sum: %i\n\\n\n\"\n,\n \nsum\n);\n\n\n    \nsystem\n(\n\"pause\"\n);\n\n    \nreturn\n \n0\n;\n\n\n}\n\n\n\n\n\n\n\nW tym przyk\u0142adzie zaprezentowa\u0142em u\u017cycie p\u0119tli \nfor\n. P\u0119tla ta oblicza sum\u0119 od 1 do n.\n\n\nKonstrukcja p\u0119tli wygl\u0105da nast\u0119puj\u0105co:\n\n\n1\n2\n3\nfor\n \n(\nint\n \nzmienna\n \n=\n \nwartosc_od_ktorej_zaczynamy\n,\n \nwarunek\n,\n \nkrok\n){\n\n    \n// kod\n\n\n}\n\n\n\n\n\n\n\nKod zostanie wykonywany tak d\u0142ugo, jak zmienna \ni\n nie osi\u0105gnie warto\u015b\u0107 \nn\n. Zmienna \ni\n zwi\u0119kszana jest o 1 (to jest nasz krok).\n\n\nZach\u0119cam do sprawdzenia dzia\u0142ania tego kodu (i nie tylko tego!).\n\n\nPrzyk\u0142ad 5\n\u00b6\n\n\nW tym przyk\u0142adzie u\u017cyli\u015bmy konstrukcji \nswitch(zmienna_liczbowa){case warunek}\n. Pos\u0142u\u017cy\u0142a ona nam do zbudowania prostego menu.\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n#include\n \n<stdio.h>\n\n\n#include\n \n<stdlib.h>\n\n\n\nint\n \nmain\n()\n\n\n{\n\n    \nint\n \nmode\n \n=\n \n-\n1\n;\n\n    \nprintf\n(\n\"\n\\t\nNuclear Weapon control panel! Welcome!\n\\n\\n\n\"\n);\n\n    \nprintf\n(\n\"Select mode:\n\\n\n 1 - destroy USA\n\\n\n 2 - Clean weapon\n\\n\n 3 - Prepare nuclear energy\n\\n\\n\n\"\n);\n\n    \nprintf\n(\n\"Selection> \"\n);\n\n    \nscanf_s\n(\n\"%i\"\n,\n \n&\nmode\n);\n\n\n\n    \nswitch\n \n(\nmode\n)\n\n    \n{\n\n    \ncase\n \n1\n:\n\n        \nprintf\n(\n\"Launching nuclear missiles!\n\\n\n\"\n);\n\n        \nbreak\n;\n\n    \ncase\n \n2\n:\n\n        \nprintf\n(\n\"Cleaning...\n\\n\n\"\n);\n\n    \ncase\n \n3\n:\n\n        \nprintf\n(\n\"Preparing...\n\\n\n\"\n);\n\n        \nbreak\n;\n\n    \ndefault\n:\n\n        \nprintf\n(\n\"Bad mode!\n\\n\n\"\n);\n\n        \nbreak\n;\n\n    \n}\n\n\n    \nsystem\n(\n\"pause\"\n);\n\n    \nreturn\n \n0\n;\n\n\n}\n\n\n\n\n\n\n\nNiestety konstrukcja \nswitch()...case\n wymaga u\u017cycia zmiennej liczbowej (lub znaku, bo znak to te\u017c liczba). Specjalnie przy drugim case nie u\u017cy\u0142em s\u0142\u00f3wka kluczowego \nbreak\n. Sprawd\u017a koniecznie dzia\u0142anie programu z \nbreak\n i bez!\n\n\nA teraz na zako\u0144czenie... praca domowa!\n\u00b6\n\n\n\n\n\u0179r\u00f3d\u0142o: https://www.redbubble.com/people/fayafshar/works/8585516-keep-calm-and-code?p=t-shirt\n\n\nW repozytorium znajdziesz solucj\u0119 o nazwie \nhomework02-task01\n.\n\n\nW solucji znajdziemy lekko zmodyfikowany kod zaprezentowany w drugim przyk\u0142adzie. Wygl\u0105da on nast\u0119puj\u0105co:\n\n\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n#include\n \n<stdio.h>\n\n\n#include\n \n<stdlib.h>\n\n\n\nint\n \nmain\n()\n\n\n{\n\n    \n// Implement data validation!\n\n    \n// Age must be an integer in range <0;150>\n\n    \n// What happens if you cause a buffer overflow (that is to say that, you enter a character string larger than 35 characters)?\n\n    \n// Force may be with you! Good luck!\n\n\n    \nchar\n \nname\n[\n35\n]\n \n=\n \n{\n \n0\n \n};\n\n    \nchar\n \nmyName\n[]\n \n=\n \n\"Alice\"\n;\n \n// char myName[] = {'A', 'l', 'i', 'c', 'e'}; lub char* myName = \"Alice\";\n\n    \nint\n \nage\n \n=\n \n0\n;\n\n    \nprintf\n(\n\"Hi, I'm %s! What's your name?: \"\n,\n \nmyName\n);\n\n    \nscanf_s\n(\n\"%s\"\n,\n \nname\n,\n \nsizeof\n(\nname\n));\n\n\n    \nprintf\n(\n\"Hi %s! How old are you? \"\n,\n \nname\n);\n\n    \nscanf_s\n(\n\"%i\"\n,\n \n&\nage\n);\n\n\n\n    \nif\n \n(\nage\n \n<\n \n18\n)\n\n    \n{\n\n        \nprintf\n(\n\"This content is not available for you! Sorry, dude!\n\\n\n\"\n);\n\n        \nprintf\n(\n\"Returning -1!\n\\n\n\"\n);\n\n        \nsystem\n(\n\"pause\"\n);\n\n        \nreturn\n \n-\n1\n;\n\n    \n}\n\n    \nelse\n \nif\n \n(\nage\n \n>\n \n150\n)\n\n    \n{\n\n        \nprintf\n(\n\"YYyhmm??\n\\n\n\"\n);\n\n        \nreturn\n \n0x029A\n;\n\n    \n}\n\n    \nelse\n\n    \n{\n\n        \nprintf\n(\n\"Ok, You're in!\n\\n\n\"\n);\n\n    \n}\n\n\n    \nsystem\n(\n\"pause\"\n);\n\n    \nreturn\n \n0\n;\n\n\n}\n\n\n\n\n\n\n\nTak jak opisa\u0142em wy\u017cej, nale\u017cy zaimplementowa\u0107 walidacje wprowadzanych danych. Nie mo\u017cna dopu\u015bci\u0107 do sytuacji takiej, \u017ce u\u017cytkownik wprowadza wiek wi\u0119kszy od 150 lat i mniejszy od 0. Zwr\u00f3\u0107 uwag\u0119, \u017ce w takiej sytuacji fragment \nelse if...\n jest zb\u0119dny.\n\n\nW przypadku podania b\u0142\u0119dnych danych, u\u017cytkownik proszony jest o ich ponowne wprowadzanie tak d\u0142ugo, a\u017c wpisze je poprawnie. :)\n\n\nPami\u0119taj tak\u017ce o czyszczeniu bufora wej\u015bciowego \nstdin\n. \nPOWODZENIA!",
            "title": "Lekcja 02: control flow, operacje wej\u015bcia"
        },
        {
            "location": "/lesson02-p1/#lekcja-2-kilka-sow-o-petlach-i-operacjach-wejscia-i-wyjscia",
            "text": "W poprzedniej lekcji poznali\u015bmy podstawowe typy danych oraz funkcje  printf() . W tej lekcji zajmiemy si\u0119 kontrol\u0105 wykonania naszego kodu.",
            "title": "Lekcja 2: kilka s\u0142\u00f3w o p\u0119tlach i operacjach wej\u015bcia i wyj\u015bcia"
        },
        {
            "location": "/lesson02-p1/#przykad-1",
            "text": "Zerknijmy na poni\u017cszy kod:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29 #include   <stdio.h>  #include   <stdlib.h>  int   main ()  { \n     char   name [ 35 ]; \n     char   myName []   =   \"Alice\" ;   // char myName[] = {'A', 'l', 'i', 'c', 'e'}; lub char* myName = \"Alice\"; \n     int   age   =   0 ; \n     printf ( \"Hi, I'm %s! What's your name?: \" ,   myName ); \n     scanf ( \"%s\" ,   name ); \n\n     printf ( \"Hi %s! How old are you? \" ,   name ); \n     scanf ( \"%i\" ,   & age ); \n\n     if   ( age   <   18 ) \n     { \n         printf ( \"This content is not available for you! Sorry, dude! \\n \" ); \n         printf ( \"Returning -1! \\n \" ); \n         system ( \"pause\" ); \n         return   - 1 ; \n     } \n     else  \n     { \n         printf ( \"Ok, You're in! \\n \" ); \n     } \n\n     system ( \"pause\" ); \n     return   0 ;  }    W pierwszych liniach funkcji main zadeklarowali\u015bmy tablice (pierwsza pusta o rozmiarze maksymalnym 35 znak\u00f3w i druga zawieraj\u0105ca napis \"Alice\"). Kazda tablica typu char powinna by\u0107 zako\u0144czona znakiem '\\0' (null-terminated string). Znak null zostanie dodany automatycznie w naszym przypadku.  Dalej nie dzieje, si\u0119 nic szczeg\u00f3lnego. Zwr\u00f3\u0107my jednak uwage na funkcje  scanf() . Jest to funkcja podobna do funkcji  printf() . Jej zadaniem jest wczytanie danych z klawiatury, nast\u0119pnie umie\u015bci\u0107 je w odpowiednim miejscu. Miejsce te definiowane jest przez  wska\u017anik . Wska\u017anik zawiera adres w pami\u0119ci RAM danej zmiennej (wskazuje na zmienn\u0105).  Tablice typu char s\u0105 automatycznie wska\u017anikami. Wska\u017anik domy\u015blnie wskazuje na pierwszy element w tablicy.  Funkcja   scanf()  przyjmuje format danych, kt\u00f3ry ma zosta\u0107 wczytany z klawiatury (tak jak w funkcji  printf() ), a nast\u0119pnie podaje si\u0119 zmienne w postaci wska\u017anikowego, czyli adresy.  W postaci zmiennych niewska\u017anikowych robimy to za pomoc\u0105 operatora  &  (przyk\u0142ad:  &x  -> dostaniemy adres zmiennej x w pami\u0119ci).  W przypadku zmiennych, kt\u00f3re s\u0105 wska\u017anikami, przekazujemy warto\u015b\u0107 tak jak zwykle.  Potem widzimy blok  if (warunek) {...} else {...} . Kod pod warunkiem  if  zostanie wykonany, je\u015bli warto\u015b\u0107 logiczna warunku da warto\u015b\u0107 true (inaczej 1). W naszym wypadku jest to wiek mniejszy od 18 lat.  Kod w bloku else zostanie wykonany w innym przypadku.  Niestety funkcja scanf() jest niebezpieczna. Jednym z zamiennik\u00f3w jest funkcja  scanf_s()  dost\u0119pna jedynie w systemach Windows. O innych zamiennikach opowiem w innej lekcji. W VS Studio mo\u017cemy wy\u0142\u0105czy\u0107 sprawdzanie bezpiecze\u0144stwa kodu poprzez wy\u0142\u0105czenie  SDL checks  w ustawieniach projektu.",
            "title": "Przyk\u0142ad 1"
        },
        {
            "location": "/lesson02-p1/#przykad-2",
            "text": "1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33 #include   <stdio.h>  #include   <stdlib.h>  #include   <string.h>  int   main ()  { \n     char   answer [ 4 ]   =   {   0   }; \n     while   ( 1 )   { \n         printf ( \"Do you know Elizabeth Turner? [yes, no, idk]: \" ); \n         scanf_s ( \"%s\" ,   answer ,   4 ); \n\n         if   ( strcmp ( answer ,   \"yes\" )   ==   0 ) \n         { \n             printf ( \"Great! \\n \" ); \n             break ; \n         } \n         else   if   ( strcmp ( answer ,   \"no\" )   ==   0 )   { \n             printf ( \"Elizabeth is an actress! \\n \" ); \n             break ; \n         } \n         else   if   ( strcmp ( answer ,   \"idk\" )   ==   0 )   { \n             printf ( \"Really!? I'm not sure if you are just stupid or you're trolling! \\n \" ); \n             break ; \n         } \n         else   { \n             printf ( \"Do you know Elizabeth Turner? [yes, no, idk]: \" ); \n             scanf_s ( \"%s\" ,   answer ,   4 ); \n         } \n     } \n\n     system ( \"pause\" ); \n     return   0 ;  }    W tym przyk\u0142adzie u\u017cyli\u015bmy biblioteki  <string.h>  do por\u00f3wnywania zmiennych \u0142a\u0144cuchowych. Funkcja  strcmpy()  por\u00f3wnuje dwa wska\u017aniki typu char i zwraca r\u00f3\u017cnic\u0119 w znakach. Je\u015bli oba stringi s\u0105 identyczne to funkcja  strcmp()  zwr\u00f3ci  0 .   Ciekawostka  Istnieje funkcja  strcmpi() , kt\u00f3ra nie zwraca uwag\u0119 na wielko\u015b\u0107 liter przy por\u00f3wnywaniu.  Inn\u0105 ciekaw\u0105 funkcj\u0105 jest  strlen() , kt\u00f3ra zwraca aktualn\u0105 d\u0142ugo\u015b\u0107 tablicy znak\u00f3w.    Uwaga!  Funkcja  scanf_s()  wymaga podania jeszcze jednego argumentu, w przypadku tekstu. Jest to maksymalna ilo\u015b\u0107 znak\u00f3w jakie mog\u0105 byc zapisane w zmiennej typu char*.",
            "title": "Przyk\u0142ad 2"
        },
        {
            "location": "/lesson02-p1/#przykad-3",
            "text": "1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35 #include   <stdio.h>  #include   <stdlib.h>  #include   <stdbool.h>  int   main ()  { \n     bool   doIt   =   false ; \n     int   counter   =   0 ; \n\n     do \n     { \n         printf ( \"Do it? \" ); \n         doIt   ==   true   ?   printf ( \"Yes! \\n \" )   :   printf ( \"No! \\n \" ); \n         counter ++ ; \n     }   while   ( doIt ); \n     printf ( \"Counter: %i \\n \" ,   counter ); \n\n     while   ( doIt   ==   1 )   // doIt == true \n     { \n         printf ( \"Incrementing counter in while loop! \\n \" ); \n         counter ++ ; \n     } \n     printf ( \"Counter: %i \\n \" ,   counter ); \n     doIt   =   1 ; \n     printf ( \"Do it? \" ); \n     doIt   ==   true   ?   printf ( \"Yes! \\n \" )   :   printf ( \"No! \\n \" ); \n     while   ( doIt   ==   true   &&   counter   <   3 ) \n     { \n         printf ( \"Incrementing counter in while loop (another loop)! \\n \" ); \n         counter   +=   1 ;   // counter++; lub counter = counter + 1; \n     } \n\n     system ( \"pause\" ); \n     return   0 ;  }    W tym przyk\u0142adzie u\u017cyli\u015bmy biblioteki  <stdbool.h> , \u017ceby m\u00f3c zdefiniowac typ zmiennej typu bool (typu logicznego). Typ logiczny mo\u017ce przyjmowa\u0107 dwie warto\u015bci:  true  albo  false  (1 albo 0).  Do kontrolowania przep\u0142ywu dzia\u0142ania u\u017cyli\u015bmy  do {...} while(warunek)  (wykonaj najperw operacje pod  do , potem sprawd\u017a, czy warunek jest prawdziwy. Je\u015bli tak, to powt\u00f3rz operacje). W konstrukcji  while(warunek)  warunek najpierw jest sprawdzany. Je\u015bli jest on prawdziwy, to kod zostanie wykonany.  Kod  counter++  inkrementuje (zwi\u0119ksza warto\u015b\u0107) zmienn\u0105  counter  o 1. Z kolei  doIt == true : operacja ? druga_operacja  to tzw. skr\u00f3cony if.  Konstrukcja skr\u00f3conego if'a wygl\u0105da tak:  warunek : (jesli prawdziwy wykonaj operacje) ? (wykonaj, je\u015bli fa\u0142sz)  Jest to r\u00f3wnowa\u017cne z:  1\n2\n3\n4\n5 if   ( warunek ){ \n     // wykonaj operacje, je\u015bli prawdziwy  }   else   { \n     // wykonaj, je\u015bli fa\u0142sz  }    &&  oznacza i logiczne (koniunkcja),  ||  - lub logiczne (alternatywa), a  !  - zaprzeczenie (negacje).   \u0179r\u00f3d\u0142o: https://pl.pinterest.com/pin/382735668317221447/",
            "title": "Przyk\u0142ad 3"
        },
        {
            "location": "/lesson02-p1/#przykad-4",
            "text": "1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18 #include   <stdio.h>  #include   <stdlib.h>  int   main ()  { \n     int   sum   =   0 ; \n     int   n   =   10 ; \n     for   ( int   i   =   1 ;   i   <=   n ;   i ++ ) \n     { \n         sum   +=   i ; \n     } \n     printf ( \"Sum: %i \\n \" ,   sum ); \n     sum   =   n   *   ( n   +   1 )   /   2 ; \n     printf ( \"Sum: %i \\n \" ,   sum ); \n\n     system ( \"pause\" ); \n     return   0 ;  }    W tym przyk\u0142adzie zaprezentowa\u0142em u\u017cycie p\u0119tli  for . P\u0119tla ta oblicza sum\u0119 od 1 do n.  Konstrukcja p\u0119tli wygl\u0105da nast\u0119puj\u0105co:  1\n2\n3 for   ( int   zmienna   =   wartosc_od_ktorej_zaczynamy ,   warunek ,   krok ){ \n     // kod  }    Kod zostanie wykonywany tak d\u0142ugo, jak zmienna  i  nie osi\u0105gnie warto\u015b\u0107  n . Zmienna  i  zwi\u0119kszana jest o 1 (to jest nasz krok).  Zach\u0119cam do sprawdzenia dzia\u0142ania tego kodu (i nie tylko tego!).",
            "title": "Przyk\u0142ad 4"
        },
        {
            "location": "/lesson02-p1/#przykad-5",
            "text": "W tym przyk\u0142adzie u\u017cyli\u015bmy konstrukcji  switch(zmienna_liczbowa){case warunek} . Pos\u0142u\u017cy\u0142a ona nam do zbudowania prostego menu.   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30 #include   <stdio.h>  #include   <stdlib.h>  int   main ()  { \n     int   mode   =   - 1 ; \n     printf ( \" \\t Nuclear Weapon control panel! Welcome! \\n\\n \" ); \n     printf ( \"Select mode: \\n  1 - destroy USA \\n  2 - Clean weapon \\n  3 - Prepare nuclear energy \\n\\n \" ); \n     printf ( \"Selection> \" ); \n     scanf_s ( \"%i\" ,   & mode ); \n\n\n     switch   ( mode ) \n     { \n     case   1 : \n         printf ( \"Launching nuclear missiles! \\n \" ); \n         break ; \n     case   2 : \n         printf ( \"Cleaning... \\n \" ); \n     case   3 : \n         printf ( \"Preparing... \\n \" ); \n         break ; \n     default : \n         printf ( \"Bad mode! \\n \" ); \n         break ; \n     } \n\n     system ( \"pause\" ); \n     return   0 ;  }    Niestety konstrukcja  switch()...case  wymaga u\u017cycia zmiennej liczbowej (lub znaku, bo znak to te\u017c liczba). Specjalnie przy drugim case nie u\u017cy\u0142em s\u0142\u00f3wka kluczowego  break . Sprawd\u017a koniecznie dzia\u0142anie programu z  break  i bez!",
            "title": "Przyk\u0142ad 5"
        },
        {
            "location": "/lesson02-p1/#a-teraz-na-zakonczenie-praca-domowa",
            "text": "\u0179r\u00f3d\u0142o: https://www.redbubble.com/people/fayafshar/works/8585516-keep-calm-and-code?p=t-shirt  W repozytorium znajdziesz solucj\u0119 o nazwie  homework02-task01 .  W solucji znajdziemy lekko zmodyfikowany kod zaprezentowany w drugim przyk\u0142adzie. Wygl\u0105da on nast\u0119puj\u0105co:   1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\n 9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40 #include   <stdio.h>  #include   <stdlib.h>  int   main ()  { \n     // Implement data validation! \n     // Age must be an integer in range <0;150> \n     // What happens if you cause a buffer overflow (that is to say that, you enter a character string larger than 35 characters)? \n     // Force may be with you! Good luck! \n\n     char   name [ 35 ]   =   {   0   }; \n     char   myName []   =   \"Alice\" ;   // char myName[] = {'A', 'l', 'i', 'c', 'e'}; lub char* myName = \"Alice\"; \n     int   age   =   0 ; \n     printf ( \"Hi, I'm %s! What's your name?: \" ,   myName ); \n     scanf_s ( \"%s\" ,   name ,   sizeof ( name )); \n\n     printf ( \"Hi %s! How old are you? \" ,   name ); \n     scanf_s ( \"%i\" ,   & age ); \n\n\n     if   ( age   <   18 ) \n     { \n         printf ( \"This content is not available for you! Sorry, dude! \\n \" ); \n         printf ( \"Returning -1! \\n \" ); \n         system ( \"pause\" ); \n         return   - 1 ; \n     } \n     else   if   ( age   >   150 ) \n     { \n         printf ( \"YYyhmm?? \\n \" ); \n         return   0x029A ; \n     } \n     else \n     { \n         printf ( \"Ok, You're in! \\n \" ); \n     } \n\n     system ( \"pause\" ); \n     return   0 ;  }    Tak jak opisa\u0142em wy\u017cej, nale\u017cy zaimplementowa\u0107 walidacje wprowadzanych danych. Nie mo\u017cna dopu\u015bci\u0107 do sytuacji takiej, \u017ce u\u017cytkownik wprowadza wiek wi\u0119kszy od 150 lat i mniejszy od 0. Zwr\u00f3\u0107 uwag\u0119, \u017ce w takiej sytuacji fragment  else if...  jest zb\u0119dny.  W przypadku podania b\u0142\u0119dnych danych, u\u017cytkownik proszony jest o ich ponowne wprowadzanie tak d\u0142ugo, a\u017c wpisze je poprawnie. :)  Pami\u0119taj tak\u017ce o czyszczeniu bufora wej\u015bciowego  stdin .  POWODZENIA!",
            "title": "A teraz na zako\u0144czenie... praca domowa!"
        }
    ]
}